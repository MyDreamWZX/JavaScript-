# 块作用域的替代方案

而with 和 catch 分句就是块作用域的两个小例子。

但随着 ES6 中引入了 let ，我们的代码终于有了创建完整、不受约束的块作用域的能力。

块作用域在功能上和代码风格上都拥有很多激动人心的新特性。
但如果我们想在 ES6 之前的环境中使用块作用域呢？
考虑下面的代码：

{

let a = 2;

console.log( a ); // 2

}

console.log( a ); // ReferenceError

这段代码在 ES6 环境中可以正常工作。但是在 ES6 之前的环境中如何才能实现这个效果？
答案是使用 catch 。

try{throw 2;}catch(a){

console.log( a ); // 2

}

console.log( a ); // ReferenceError

天啊！这些代码既丑陋又奇怪。我们看见一个会强制抛出错误的 try/catch ，但是它抛出
块作用域的替代方案 ｜ 61的错误就是一个值 2 ，然后 catch 分句中的变量声明会接收到这个值。头疼！没错， catch 分句具有块作用域，因此它可以在 ES6 之前的环境中作为块作用域的替代方案。

“但是，”你可能会说，“鬼才要写这么丑陋的代码！”没错，没人写的代码像 CoffeeScript
编译器输出的代码，但这不是重点。

重点是工具可以将 ES6 的代码转换成能在 ES6 之前环境中运行的形式。你可以使用块作用
域来写代码，并享受它带来的好处，然后在构建时通过工具来对代码进行预处理，使之可
以在部署时正常工作。

事实上，这是向 ES6 中的所有（好吧，不是所有而是大部分）功能迁移的首选方式：在从
ES6 之前的环境向 ES6 过渡时，使用代码转换工具来对 ES6 代码进行处理，生成兼容 ES5
的代码。

B.1　Traceur
Google 维护着一个名为 Traceur 的项目，该项目正是用来将 ES6 代码转换成兼容 ES6 之前
的环境（大部分是 ES5，但不是全部）。TC39 委员会依赖这个工具（也有其他工具）来测
试他们指定的语义化相关的功能。

Traceur 会将我们的代码片段转换成什么样子？你能猜到的！

{

try {

throw undefined;

} catch (a) {

a = 2;

console.log( a );

}

}
console.log( a );

通过使用这样的工具，我们就可以在使用块作用域时无需考虑目标平台是否是 ES6 环境，
因为 try/catch 从 ES3 开始就存在了（并且一直是这样工作的）。

B.2　隐式和显式作用域
在第 3 章中介绍块作用域时，我们的代码有一些可维护性和可扩展性方面的缺陷。有没有
其他可以使用块作用域，并且还能避免这种缺陷的途径？
考虑下面这种 let 的使用方法，它被称作 let 作用域或 let 声明（对比前面的 let 定义）。

62 ｜ 附录 B

let (a = 2) {

console.log( a ); // 2

}
console.log( a ); // ReferenceError

同隐式地劫持一个已经存在的作用域不同， let 声明会创建一个显示的作用域并与其进行
绑定。显式作用域不仅更加突出，在代码重构时也表现得更加健壮。在语法上，通过强制
性地将所有变量声明提升到块的顶部来产生更简洁的代码。这样更容易判断变量是否属于
某个作用域。

这种模式同很多人在函数作用域中手动将 var 声明提升到函数顶部的方式很接近。 let 声
明有意将变量声明放在块的顶部，如果你并没有到处使用 let 定义，那么你的块作用域就
很容易辨识和维护。

但是这里有一个小问题， let 声明并不包含在 ES6 中。官方的 Traceur 编译器也不接受这
种形式的代码。

我们有两个选择，使用合法的 ES6 语法并且在代码规范性上做一些妥协。

/*let*/ { let a = 2;

console.log( a );

}

console.log( a ); // ReferenceError

工具就是用来解决问题的。因此另外一个选择就是编写显式 let 声明，然后通过工具将其
转换成合法的、可以工作的代码。

因此我开发了一个名为 let-er 的工具来解决这个问题。let-er 是一个构建时的代码转换器，
但它唯一的作用就是找到 let 声明并对其进行转换。它不会处理包括 let 定义在内的任何
其他代码。你可以安全地将 let-er 应用在 ES6 代码转换的第一步，如果有必要，接下来也
可以把代码传递给 Traceur 等工具。

此外，let-er 还有一个设置项 --es6 ，开启它（默认是关闭的）会改变生成代码的种类。开
启这个设置项时 let-er 会生成完全标准的 ES6 代码，而不会生成通过 try/catch 进行 hack
的 ES3 替代方案：

{

let a = 2;

console.log( a );

}

console.log( a ); // ReferenceError

因此你马上就可以在 ES6 之前的所有环境中使用 let-er，当你只关注 ES6 环境时，可以开
块作用域的替代方案 ｜ 63

启设置项，这样就会生成标准的 ES6 代码。

更重要的，你甚至可以使用尚未成为 ES 官方标准的、更加好用的显式 let 声明。

B.3　性能
最后简单地看一下 try/catch 带来的性能问题，并尝试回答“为什么不直接使用 IIFE 来创
建作用域”这个问题。

首先， try/catch 的性能的确很糟糕，但技术层面上没有合理的理由来说明 try/catch 必
须这么慢，或者会一直慢下去。自从 TC39 支持在 ES6 的转换器中使用 try/catch 后，
Traceur 团队已经要求 Chrome 对 try/catch 的性能进行改进，他们显然有很充分的动机来
做这件事情。

其次，IIFE 和 try/catch 并不是完全等价的，因为如果将一段代码中的任意一部分拿出来
用函数进行包裹，会改变这段代码的含义，其中的 this 、 return 、 break 和 contine 都会
发生变化。IIFE 并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。

最后问题就变成了：你是否想要块作用域？如果你想要，这些工具就可以帮助你。如果不
想要，继续使用 var 来写代码就好了！